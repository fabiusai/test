<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <title>Converti Excel – Data Fissa in C + Conversione D</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      font-family: sans-serif;
      margin: 2rem;
    }
    h1 {
      margin-bottom: 1rem;
    }
    input, button {
      font-size: 1rem;
      margin: 0.5rem 0;
      padding: 0.5rem;
    }
    #log {
      margin-top: 1rem;
      color: #555;
    }
  </style>
</head>
<body>
  <h1>Converti Excel – Colonna C con Primo Giorno del Mese più Vecchio in D</h1>
  <p>
    Carica qui il tuo file Excel (con colonne “C” e “D” in formato testo `gg/MM/AAAA`),<br>
    e otterrai un nuovo file Excel in cui:
    <ul>
      <li>Colonna C = primo giorno del mese relativo alla data più vecchia di colonna D</li>
      <li>Colonna D = convertita in veri campi data</li>
    </ul>
  </p>

  <!-- Input per il file Excel di partenza -->
  <input type="file" id="file-input" accept=".xlsx, .xls" />

  <!-- Pulsante per avviare la conversione -->
  <button id="convert-btn" disabled>Converti e Scarica</button>

  <!-- Elemento per mostrare messaggi di log/errore -->
  <div id="log"></div>

  <!-- Includo la libreria SheetJS via CDN -->
  <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>

  <script>
    (function() {
      const fileInput = document.getElementById('file-input');
      const convertBtn = document.getElementById('convert-btn');
      const logEl = document.getElementById('log');
      let workbookBinary; // Buffer del file caricato

      // Quando viene selezionato un file, carichiamo l'ArrayBuffer
      fileInput.addEventListener('change', function(evt) {
        logEl.textContent = "";
        convertBtn.disabled = true;
        const file = evt.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
          workbookBinary = e.target.result; // ArrayBuffer del file caricato
          logEl.textContent = `File "${file.name}" caricato, dimensione ${file.size} byte.`;
          convertBtn.disabled = false;
        };
        reader.onerror = function() {
          logEl.textContent = "Errore nel leggere il file.";
        };
        reader.readAsArrayBuffer(file);
      });

      // Funzione di utilità: trasforma una stringa "gg/MM/AAAA" in Date
      function parseDate_ddmmyyyy(str) {
        const parts = str.split('/');
        if (parts.length !== 3) return null;
        const giorno = parseInt(parts[0], 10);
        const mese = parseInt(parts[1], 10) - 1; // in JS i mesi partono da 0
        const anno = parseInt(parts[2], 10);
        if (isNaN(giorno) || isNaN(mese) || isNaN(anno)) return null;
        return new Date(anno, mese, giorno);
      }

      // Quando l'utente clicca “Converti e Scarica”
      convertBtn.addEventListener('click', function() {
        if (!workbookBinary) {
          logEl.textContent = "Nessun file caricato.";
          return;
        }
        logEl.textContent = "Processo in corso… attendi qualche istante.";

        // 1) Leggo il workbook da ArrayBuffer
        const wb = XLSX.read(workbookBinary, { type: 'array', cellDates: false, raw: true });

        // 2) Per ogni Foglio (sheet) del workbook:
        wb.SheetNames.forEach(function(sheetName) {
          const ws = wb.Sheets[sheetName];
          if (!ws || !ws['!ref']) return;

          // Determino range di celle (es. "A1:F20")
          const range = XLSX.utils.decode_range(ws['!ref']);
          const datesInD = []; // array temporaneo per raccogliere le date convertite di colonna D

          // Prima passata: converto colonna D da testo a Date e memorizzo le date per trovare la più vecchia
          for (let row = range.s.r + 1; row <= range.e.r; row++) {
            const dCellAddr = { c: 3, r: row }; // colonna D = indice 3
            const dCellRef = XLSX.utils.encode_cell(dCellAddr);
            const dCell = ws[dCellRef];
            if (!dCell) continue;

            // Se è stringa (o numero estraneo), provo a convertirlo in Date
            if (dCell.t === 's' || dCell.t === 'str' || dCell.t === 'n') {
              const textVal = String(dCell.v).trim();
              const jsDate = parseDate_ddmmyyyy(textVal);
              if (jsDate && !isNaN(jsDate.getTime())) {
                // Memorizzo la data per il calcolo del minimo
                datesInD.push(jsDate);
                // Sovrascrivo la cella D con tipo “d” e valore Date
                dCell.t = 'd';
                dCell.v = jsDate;
                dCell.z = 'dd/mm/yyyy'; // mantengo la stessa formattazione
              }
            }
          }

          // Se non ci sono date valide in colonna D, salto la logica su colonna C
          if (datesInD.length === 0) {
            console.warn(`Foglio "${sheetName}": nessuna data valida trovata in colonna D.`);
            return;
          }

          // Trovo la data più vecchia nell'array (min)
          let minDate = datesInD[0];
          for (let i = 1; i < datesInD.length; i++) {
            if (datesInD[i] < minDate) {
              minDate = datesInD[i];
            }
          }

          // Calcolo il primo giorno di quel mese
          const primoGiorno = new Date(minDate.getFullYear(), minDate.getMonth(), 1);

          // Seconda passata: imposto TUTTE le celle di colonna C al primo giorno del mese
          for (let row = range.s.r + 1; row <= range.e.r; row++) {
            const cCellAddr = { c: 2, r: row }; // colonna C = indice 2
            const cCellRef = XLSX.utils.encode_cell(cCellAddr);
            // Creo o sovrascrivo la cella come tipo “d”
            ws[cCellRef] = {
              t: 'd',
              v: new Date(primoGiorno.getTime()), // assegno una copia della data
              z: 'dd/mm/yyyy'
            };
          }
        });

        // 3) Genero il nuovo file Excel: Array di byte
        const newWbArray = XLSX.write(wb, {
          bookType: 'xlsx',
          type: 'array',
          cellDates: true // fondamentale per esportare le date
        });

        // 4) Creo un Blob e forzo il download
        const blob = new Blob([newWbArray], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'converted_dates.xlsx';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        logEl.textContent = `Download avviato: il file “converted_dates.xlsx” contiene ora la colonna C con ${formatDate(primoGiorno)} e colonna D convertita in data.`;
      });

      // Funzione di comodo per mostrare la data nel log
      function formatDate(dt) {
        const gg = String(dt.getDate()).padStart(2, '0');
        const mm = String(dt.getMonth() + 1).padStart(2, '0');
        const yyyy = dt.getFullYear();
        return `${gg}/${mm}/${yyyy}`;
      }
    })();
  </script>
</body>
</html>
