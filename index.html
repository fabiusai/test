<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Talkwalker Report Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>        .data-table th.sortable::after, .data-table th.sort-asc::after, .data-table th.sort-desc::after { display:none !important; }

        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        :root {
            --primary-blue: #003d82;
            --secondary-blue: #0056b3;
            --poste-yellow: #ffd100;
            --light-blue: #e6f3ff;
            --success-green: #28a745;
            --warning-orange: #ffc107;
            --danger-red: #dc3545;
            --neutral-gray: #6c757d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Inter", "Avenir Next LT Pro", "Segoe UI", sans-serif;
            background-color: #f8f9fa;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, var(--primary-blue), var(--secondary-blue));
            color: white;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,61,130,0.15);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            font-family: "Avenir Next LT Pro", "Inter", sans-serif;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .upload-section {
            background: white;
            border-radius: 16px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.08);
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .upload-section:hover {
            border-color: var(--light-blue);
        }

        .upload-area {
            border: 3px dashed var(--primary-blue);
            border-radius: 16px;
            padding: 50px;
            text-align: center;
            background: var(--light-blue);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .upload-area:hover {
            background: #d0e8ff;
            transform: translateY(-4px);
            box-shadow: 0 12px 28px rgba(0,61,130,0.15);
        }

        .upload-icon {
            font-size: 4rem;
            color: var(--primary-blue);
            margin-bottom: 20px;
            display: block;
        }

        .file-input {
            display: none;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        .input-group label {
            font-weight: 600;
            color: var(--primary-blue);
            margin-bottom: 10px;
            font-size: 0.95rem;
            font-family: "Avenir Next LT Pro", "Inter", sans-serif;
        }

        .input-group input {
            padding: 15px 18px;
            border: 2px solid #e0e6ed;
            border-radius: 12px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: #fafbfc;
        }

        .input-group input:focus {
            outline: none;
            border-color: var(--primary-blue);
            background: white;
            box-shadow: 0 0 0 3px rgba(0,61,130,0.1);
        }

        .btn {
            background: linear-gradient(135deg, var(--primary-blue), var(--secondary-blue));
            color: white;
            border: none;
            padding: 18px 35px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: "Avenir Next LT Pro", "Inter", sans-serif;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,61,130,0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, var(--poste-yellow), #ffed4a);
            color: var(--primary-blue);
        }

        .card {
            background: white;
            border-radius: 16px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.08);
            margin-bottom: 30px;
            overflow: hidden;
            border: 1px solid #f0f4f8;
        }

        .card-header {
            background: linear-gradient(135deg, var(--light-blue), #f0f8ff);
            border-bottom: 4px solid var(--poste-yellow);
            padding: 25px;
            font-weight: normal;
            color: var(--primary-blue);
            font-size: 1.3rem;
            font-family: "Avenir Next LT Pro", "Inter", sans-serif;
            text-transform: uppercase;
        }

        .card-body {
            padding: 30px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: linear-gradient(135deg, var(--primary-blue), var(--secondary-blue));
            color: white;
            padding: 30px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 8px 24px rgba(0,61,130,0.2);
            transition: transform 0.3s ease;
        }

        .metric-card:hover {
            transform: translateY(-5px);
        }

        .metric-value {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 12px;
            font-family: "Avenir Next LT Pro", "Inter", sans-serif;
        }

        .metric-label {
            font-size: 1rem;
            opacity: 0.9;
            font-weight: 500;
        }

        .charts-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .chart-container {
            position: relative;
            height: 500px;
            padding: 25px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 auto;
        }

        .sentiment-container {
            position: relative;
            height: 500px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .table-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 25px 0;
            gap: 20px;
            flex-wrap: wrap;
        }

        .rows-selector {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .rows-selector select {
            padding: 12px 16px;
            border: 2px solid #e0e6ed;
            border-radius: 8px;
            background: white;
            font-size: 0.95rem;
        }

        .table-wrapper {
            overflow-x: auto;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            background: white;
        }

        .data-table th,
        .data-table td {
            border: 1px solid #e8ecef;
            padding: 12px 10px;
            text-align: center;
            vertical-align: middle;
        }
        .data-table td a{
          color: var(--primary-blue);
          text-decoration: underline dotted;
          font-weight: 600;
          position: relative;
          transition: all .2s ease;
        }

        .data-table td a::after{
          content: '‚Üó';
          font-size: .75em;
          margin-left: .25rem;
          opacity: 0;
          transform: translateY(-2px);
          transition: opacity .2s ease, transform .2s ease;
        }

        .data-table td a:hover{
          background: var(--light-blue);
          text-decoration-color: var(--secondary-blue);
        }

        .data-table td a:hover::after{
          opacity: 1;
          transform: translateY(0);
        }

        .data-table th:first-child {
            width: 180px;
            min-width: 180px;
            max-width: 180px;
        }

        .data-table th:hover {
            background: linear-gradient(135deg, #cce7ff, #e0f0ff);
        }

        .data-table th.sortable::after {
            content: ' ‚ÜïÔ∏è';
            font-size: 12px;
            margin-left: 5px;
        }

        .data-table th.sort-asc::after {
            content: ' ‚Üë';
            color: var(--primary-blue);
            font-weight: bold;
        }

        .data-table th.sort-desc::after {
            content: ' ‚Üì';
            color: var(--primary-blue);
            font-weight: bold;
        }

        .data-table td.text-left {
            text-align: left;
        }

        .data-table td.content-cell {
            max-width: 200px;
            font-size: 0.8rem;
            word-wrap: break-word;
        }

        .data-table td.profile-name-cell {
            text-align: center;
            font-size: 1rem;
            font-weight: 600;
            color: var(--primary-blue);
        }

        .data-table td.channel-cell {
            text-align: center;
            font-size: 0.85rem;
        }

        .data-table tr:nth-child(even) {
            background-color: #fafbfc;
        }

        .data-table tr:hover {
            background-color: var(--light-blue);
        }

        .export-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .error-message, .success-message {
            padding: 18px 24px;
            border-radius: 12px;
            margin: 20px 0;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            border-left: 4px solid var(--danger-red);
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            border-left: 4px solid var(--success-green);
        }

        .analysis-header {
            text-align: center;
            margin: 40px 0;
            padding: 30px;
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.06);
        }

        .analysis-title {
            font-size: 2.2rem;
            color: var(--primary-blue);
            margin-bottom: 15px;
            font-weight: 700;
            font-family: "Avenir Next LT Pro", "Inter", sans-serif;
        }

        .analysis-subtitle {
            color: var(--neutral-gray);
            font-size: 1.1rem;
            font-weight: 500;
        }

        #results {
            display: none;
        }

        .sentiment-note {
            font-size: 0.85rem;
            color: var(--neutral-gray);
            font-style: italic;
            margin-top: 20px;
            text-align: center;
        }

        .channel-icon {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            vertical-align: middle;
        }

        @media (max-width: 1200px) {
            .charts-row {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .container { 
                padding: 15px; 
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .form-grid { 
                grid-template-columns: 1fr; 
            }
            
            .metrics-grid { 
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
            }
            
            .export-section { 
                grid-template-columns: 1fr; 
            }
            
            .table-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .data-table th,
            .data-table td {
                padding: 8px 6px;
                font-size: 0.8rem;
            }
        }
    
/* ‚Äî‚Äî‚Äî Custom patch: Blu‚ÄëPoste table header ‚Äî‚Äî‚Äî */
.data-table th{
  background:#1d48b4;
  color:#ffffff;
  font-family:"Avenir Next LT Pro","Inter",sans-serif;
  font-weight:300;          /* Light */
  text-transform:uppercase;
  font-size:1rem;           /* slightly larger than row text */
}
.data-table th:hover{
  background:#1d48b4;
}
</style>
</head>
<body>

    <div class="container">
        <div class="header">
            <h1>üìä Report Talkwalker</h1>
            <p>Analisi avanzata dei dati social media</p>
        </div>

        <div class="upload-section">
            <div class="upload-area" onclick="document.getElementById('fileInput').click()">
                <span class="upload-icon">üìÅ</span>
                <h3>Carica File Excel di Talkwalker</h3>
                <p>Clicca qui o trascina il file .xlsx/.xls per iniziare l'analisi</p>
                <input type="file" id="fileInput" class="file-input" accept=".xlsx,.xls" onchange="handleFile(event)">
            </div>
            
            <div class="form-grid">
                <div class="input-group">
                    <label for="argomento">Argomento dell'analisi</label>
                    <input type="text" id="argomento" placeholder="Es. Brand Monitoring, Crisis Management, Campaign Analysis">
                </div>
                <div class="input-group">
                    <label for="dataInizio">Data inizio</label>
                    <input type="date" id="dataInizio">
                </div>
                <div class="input-group">
                    <label for="dataFine">Data fine</label>
                    <input type="date" id="dataFine">
                </div>
            </div>
            
            <button class="btn" id="generateBtn" onclick="generateReport()">
                üöÄ Genera Report
            </button>
        </div>

        <div id="results">
            <div class="analysis-header">
                <h2 class="analysis-title" id="analysisTitle">Analisi social su [Argomento]</h2>
                <p class="analysis-subtitle" id="analysisSubtitle">Report riferito al periodo: [Date Range]</p>
            </div>

            <div class="card">
                <div class="card-header">Metriche Generali</div>
                <div class="card-body">
                    <div class="metrics-grid" id="metricsGrid">
                    </div>
                </div>
            </div>

            <div class="charts-row">
                <div class="card">
                    <div class="card-header">Post per Canale</div>
                    <div class="card-body">
                        <div class="chart-container">
                            <div id="channelChart"></div>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <div class="card-header">Analisi del Sentiment</div>
                    <div class="card-body">
                        <div class="sentiment-container" id="sentimentContainer">
                        </div>
                        <p class="sentiment-note">Fonte dati: Talkwalker - Sentiment calcolato dalla piattaforma in base al ¬´tono¬ª generale del contenuto.</p>
                    </div>
                </div>
            </div>

            <div class="table-controls">
                <div class="rows-selector">
                    <label for="maxRows">Mostra:</label>
                    <select id="maxRows" onchange="updateTable()">
                        <option value="5">5 righe</option>
                        <option value="10" selected>10 righe</option>
                        <option value="15">15 righe</option>
                        <option value="20">20 righe</option>
                        <option value="25">25 righe</option>
                        <option value="all">Tutti i risultati</option>
                    </select>
                </div>
                <button class="btn btn-secondary" onclick="updateTable()">
                    Aggiorna Tabella
                </button>
            </div>

            <div class="card">
                <div class="card-header">Post di Maggiore Rilievo</div>
                <div class="card-body">
                    <div class="table-wrapper">
                        <table class="data-table" id="dataTable">
                            <thead>
                                <tr>
                                    <th class="sortable" onclick="sortTable(0)">Nome Profilo</th>
                                    <th class="sortable" onclick="sortTable(1)">Canale</th>
                                    <th class="sortable" onclick="sortTable(2)">Data e Ora</th>
                                    <th>Contenuto</th>
                                    <th class="sortable" onclick="sortTable(4)">Followers</th>
                                    <th class="sortable" onclick="sortTable(5)">Commenti</th>
                                    <th class="sortable" onclick="sortTable(6)">Like e Reazioni</th>
                                    <th class="sortable" onclick="sortTable(7)">Condivisioni</th>
                                </tr>
                            </thead>
                            <tbody>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">Esportazione Dati</div>
                <div class="card-body">
                    <div class="export-section">
                        <button class="btn" onclick="exportExcel()">
                            üìä Esporta Excel
                        </button>
                        <button class="btn btn-secondary" onclick="exportHTML()">
                            üåê Esporta HTML
                        </button>
                        <button class="btn" onclick="exportMetricsSVG()">
                            üìä Esporta Metriche SVG
                        </button>
                        <button class="btn" onclick="exportChannelChartSVG()">
                            üìä Esporta Grafico Canali SVG
                        </button>
                        <button class="btn" onclick="exportSentimentChartSVG()">
                            üìä Esporta Grafico Sentiment SVG
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
    let currentData = [];
    let sortColumn = -1;
    let sortDirection = 'asc';
    let displayedData = [];

    function showError(message) {
        const existing = document.querySelector('.error-message');
        if (existing) existing.remove();
        
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.innerHTML = `‚ö†Ô∏è ${message}`;
        document.querySelector('.upload-section').appendChild(errorDiv);
    }

    function showSuccess(message) {
        const existing = document.querySelector('.success-message, .error-message');
        if (existing) existing.remove();
        
        const successDiv = document.createElement('div');
        successDiv.className = 'success-message';
        successDiv.innerHTML = `‚úÖ ${message}`;
        document.querySelector('.upload-section').appendChild(successDiv);
    }

    function handleFile(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { 
                    type: 'array',
                    cellDates: true,
                    cellNF: false,
                    cellText: false
                });
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, {
                    raw: false,
                    dateNF: 'yyyy-mm-dd"T"hh:mm:ss'
                });

                if (jsonData.length === 0) {
                    showError('Il file Excel sembra essere vuoto.');
                    return;
                }

                currentData = jsonData;
                document.getElementById('generateBtn').disabled = false;
                showSuccess(`File caricato con successo! ${jsonData.length} righe trovate.`);
                autoDetectDateRange();

            } catch (error) {
                console.error('Errore lettura file:', error);
                showError('Errore nella lettura del file Excel. Assicurati che sia in formato .xlsx o .xls.');
            }
        };
        reader.readAsArrayBuffer(file);
    }

    function autoDetectDateRange() {
        if (currentData.length === 0) return;

        const dates = currentData
            .map(row => {
                if (!row.published) return null;
                
                let date;
                if (typeof row.published === 'number') {
                    date = new Date((row.published - 25569) * 86400 * 1000);
                } else {
                    date = new Date(row.published);
                }
                
                if (!isNaN(date.getTime()) && date.getFullYear() >= 2020) {
                    return date;
                }
                return null;
            })
            .filter(date => date !== null)
            .sort((a, b) => a - b);

        if (dates.length > 0) {
            const startDate = dates[0];
            const endDate = dates[dates.length - 1];
            document.getElementById('dataInizio').value = startDate.toISOString().split('T')[0];
            document.getElementById('dataFine').value = endDate.toISOString().split('T')[0];
        }
    }

    function getChannelName(domainUrl) {
        if (!domainUrl) return 'Altro';
        
        let cleanUrl = domainUrl.toLowerCase()
            .replace(/^https?:\/\//, '')
            .replace(/^www\./, '')
            .split('/')[0]
            .replace('.com', '');
        
        const channelMap = {
            'twitter': 'X (Twitter)',
            'x': 'X (Twitter)',
            'instagram': 'Instagram',
            'facebook': 'Facebook',
            'linkedin': 'Linkedin',
            'youtube': 'Youtube',
            'tiktok': 'Tiktok',
            'reddit': 'Reddit',
            'pinterest': 'Pinterest'
        };
        
        return channelMap[cleanUrl] || cleanUrl.charAt(0).toUpperCase() + cleanUrl.slice(1) || 'Altro';
    }

    function formatNumber(num) {
        if (num >= 1000000) {
            const millions = num / 1000000;
            const rounded = millions >= 10 ? Math.round(millions).toString()
                                            : millions.toFixed(2);
            return rounded.replace('.', ',').replace(/,00$/, '') + 'M';
        } else if (num >= 1000) {
            if (num === 1000) return 'K';
            const thousands = num / 1000;
            const rounded = thousands >= 10 ? Math.round(thousands).toString()
                                             : thousands.toFixed(2);
            return rounded.replace('.', ',').replace(/,00$/, '') + 'K';
        } else {
            return num.toString().replace('.', ',');
        }
    }

    function formatTableValue(value) {
        const numValue = parseFloat(value) || 0;
        return numValue === 0 ? '' : formatNumber(numValue);
    }

    function getChannelIconSVG(channel, x, y, size = 24) {
        const iconColor = '#003d82';
        
        switch (channel.toLowerCase()) {
            case 'facebook':
                return `<svg x="${x}" y="${y}" width="${size}" height="${size}" viewBox="0 0 24 24" fill="${iconColor}">
                    <path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/>
                </svg>`;
            case 'instagram':
                return `<svg x="${x}" y="${y}" width="${size}" height="${size}" viewBox="0 0 24 24" fill="${iconColor}">
                    <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838a6.162 6.162 0 100 12.324 6.162 6.162 0 000-12.324zM12 16a4 4 0 110-8 4 4 0 010 8zm6.406-11.845a1.44 1.44 0 100 2.881 1.44 1.44 0 000-2.881z"/>
                </svg>`;
            case 'x (twitter)':
                return `<svg x="${x}" y="${y}" width="${size}" height="${size}" viewBox="0 0 24 24" fill="${iconColor}">
                    <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                </svg>`;
            case 'linkedin':
                return `<svg x="${x}" y="${y}" width="${size}" height="${size}" viewBox="0 0 24 24" fill="${iconColor}">
                    <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433a2.062 2.062 0 01-2.063-2.065 2.064 2.064 0 112.063 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
                </svg>`;
            case 'youtube':
                return `<svg x="${x}" y="${y}" width="${size}" height="${size}" viewBox="0 0 24 24" fill="${iconColor}">
                    <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                </svg>`;
            case 'tiktok':
                return `<svg x="${x}" y="${y}" width="${size}" height="${size}" viewBox="0 0 24 24" fill="${iconColor}">
                    <path d="M12.525.02c1.31-.02 2.61-.01 3.91-.02.08 1.53.63 3.09 1.75 4.17 1.12 1.11 2.7 1.62 4.24 1.79v4.03c-1.44-.05-2.89-.35-4.2-.97-.57-.26-1.1-.59-1.62-.93-.01 2.92.01 5.84-.02 8.75-.08 1.4-.54 2.79-1.35 3.94-1.31 1.92-3.58 3.17-5.91 3.21-1.43.08-2.86-.31-4.08-1.03-2.02-1.19-3.44-3.37-3.65-5.71-.02-.5-.03-1-.01-1.49.18-1.9 1.12-3.72 2.58-4.96 1.66-1.44 3.98-2.13 6.15-1.72.02 1.48-.04 2.96-.04 4.44-.99-.32-2.15-.23-3.02.37-.63.41-1.11 1.04-1.36 1.75-.21.51-.15 1.07-.14 1.61.24 1.64 1.82 3.02 3.5 2.87 1.12-.01 2.19-.66 2.77-1.61.19-.33.4-.67.41-1.06.1-1.79.06-3.57.07-5.36.01-4.03-.01-8.05.02-12.07z"/>
                </svg>`;
            case 'reddit':
                return `<svg x="${x}" y="${y}" width="${size}" height="${size}" viewBox="0 0 24 24" fill="${iconColor}">
                    <path d="M12 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0zm5.01 4.744c.688 0 1.25.561 1.25 1.249a1.25 1.25 0 0 1-2.498.056l-2.597-.547-.8 3.747c1.824.07 3.48.632 4.674 1.488.308-.309.73-.491 1.207-.491.968 0 1.754.786 1.754 1.754 0 .716-.435 1.333-1.01 1.614a3.111 3.111 0 0 1 .042.52c0 2.694-3.13 4.87-7.004 4.87-3.874 0-7.004-2.176-7.004-4.87 0-.183.015-.366.043-.534A1.748 1.748 0 0 1 4.028 12c0-.968.786-1.754 1.754-1.754.463 0 .898.196 1.207.49 1.207-.883 2.878-1.43 4.744-1.487l.885-4.182a.342.342 0 0 1 .14-.197.35.35 0 0 1 .238-.042l2.906.617a1.214 1.214 0 0 1 1.108-.701zM9.25 12C8.561 12 8 12.562 8 13.25c0 .687.561 1.248 1.25 1.248.687 0 1.248-.561 1.248-1.249 0-.688-.561-1.249-1.249-1.249zm5.5 0c-.687 0-1.248.561-1.248 1.25 0 .687.561 1.248 1.249 1.248.688 0 1.249-.561 1.249-1.249 0-.687-.562-1.249-1.25-1.249zm-5.466 3.99a.327.327 0 0 0-.231.094.33.33 0 0 0 0 .463c.842.842 2.484.913 2.961.913.477 0 2.105-.056 2.961-.913a.361.361 0 0 0 .029-.463.33.33 0 0 0-.464 0c-.547.533-1.684.73-2.512.73-.828 0-1.979-.196-2.512-.73a.326.326 0 0 0-.232-.095z"/>
                </svg>`;
            case 'pinterest':
                return `<svg x="${x}" y="${y}" width="${size}" height="${size}" viewBox="0 0 24 24" fill="${iconColor}">
                    <path d="M12.017 0C5.396 0 .029 5.367.029 11.987c0 5.079 3.158 9.417 7.618 11.174-.105-.949-.199-2.403.041-3.439.219-.937 1.406-5.957 1.406-5.957s-.359-.72-.359-1.781c0-1.663.967-2.911 2.168-2.911 1.024 0 1.518.769 1.518 1.688 0 1.029-.653 2.567-.992 3.992-.285 1.193.6 2.165 1.775 2.165 2.128 0 3.768-2.245 3.768-5.487 0-2.861-2.063-4.869-5.008-4.869-3.41 0-5.409 2.562-5.409 5.199 0 1.033.394 2.143.889 2.741.093.113.105.212.078.326-.085.354-.275 1.122-.312 1.279-.053.225-.172.271-.402.165-1.495-.69-2.433-2.878-2.433-4.646 0-3.776 2.748-7.252 7.92-7.252 4.158 0 7.392 2.967 7.392 6.923 0 4.135-2.607 7.462-6.233 7.462-1.214 0-2.357-.629-2.746-1.378l-.748 2.853c-.271 1.043-1.002 2.35-1.492 3.146C9.57 23.812 10.763 24.009 12.017 24.009c6.624 0 11.99-5.367 11.99-11.988C24.007 5.367 18.641.001.012.001z"/>
                </svg>`;
            default:
                return `<circle cx="${x + size/2}" cy="${y + size/2}" r="${size/2}" fill="${iconColor}"/>`;
        }
    }

    function getChannelIconHTML(channel) {
        const iconColor = '#003d82';
        
        switch (channel.toLowerCase()) {
            case 'facebook':
                return `<svg class="channel-icon" viewBox="0 0 24 24" fill="${iconColor}">
                    <path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/>
                </svg>`;
            case 'instagram':
                return `<svg class="channel-icon" viewBox="0 0 24 24" fill="${iconColor}">
                    <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838a6.162 6.162 0 100 12.324 6.162 6.162 0 000-12.324zM12 16a4 4 0 110-8 4 4 0 010 8zm6.406-11.845a1.44 1.44 0 100 2.881 1.44 1.44 0 000-2.881z"/>
                </svg>`;
            case 'x (twitter)':
                return `<svg class="channel-icon" viewBox="0 0 24 24" fill="${iconColor}">
                    <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                </svg>`;
            case 'linkedin':
                return `<svg class="channel-icon" viewBox="0 0 24 24" fill="${iconColor}">
                    <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433a2.062 2.062 0 01-2.063-2.065 2.064 2.064 0 112.063 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
                </svg>`;
            case 'youtube':
                return `<svg class="channel-icon" viewBox="0 0 24 24" fill="${iconColor}">
                    <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                </svg>`;
            case 'tiktok':
                return `<svg class="channel-icon" viewBox="0 0 24 24" fill="${iconColor}">
                    <path d="M12.525.02c1.31-.02 2.61-.01 3.91-.02.08 1.53.63 3.09 1.75 4.17 1.12 1.11 2.7 1.62 4.24 1.79v4.03c-1.44-.05-2.89-.35-4.2-.97-.57-.26-1.1-.59-1.62-.93-.01 2.92.01 5.84-.02 8.75-.08 1.4-.54 2.79-1.35 3.94-1.31 1.92-3.58 3.17-5.91 3.21-1.43.08-2.86-.31-4.08-1.03-2.02-1.19-3.44-3.37-3.65-5.71-.02-.5-.03-1-.01-1.49.18-1.9 1.12-3.72 2.58-4.96 1.66-1.44 3.98-2.13 6.15-1.72.02 1.48-.04 2.96-.04 4.44-.99-.32-2.15-.23-3.02.37-.63.41-1.11 1.04-1.36 1.75-.21.51-.15 1.07-.14 1.61.24 1.64 1.82 3.02 3.5 2.87 1.12-.01 2.19-.66 2.77-1.61.19-.33.4-.67.41-1.06.1-1.79.06-3.57.07-5.36.01-4.03-.01-8.05.02-12.07z"/>
                </svg>`;
            case 'reddit':
                return `<svg class="channel-icon" viewBox="0 0 24 24" fill="${iconColor}">
                    <path d="M12 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0zm5.01 4.744c.688 0 1.25.561 1.25 1.249a1.25 1.25 0 0 1-2.498.056l-2.597-.547-.8 3.747c1.824.07 3.48.632 4.674 1.488.308-.309.73-.491 1.207-.491.968 0 1.754.786 1.754 1.754 0 .716-.435 1.333-1.01 1.614a3.111 3.111 0 0 1 .042.52c0 2.694-3.13 4.87-7.004 4.87-3.874 0-7.004-2.176-7.004-4.87 0-.183.015-.366.043-.534A1.748 1.748 0 0 1 4.028 12c0-.968.786-1.754 1.754-1.754.463 0 .898.196 1.207.49 1.207-.883 2.878-1.43 4.744-1.487l.885-4.182a.342.342 0 0 1 .14-.197.35.35 0 0 1 .238-.042l2.906.617a1.214 1.214 0 0 1 1.108-.701zM9.25 12C8.561 12 8 12.562 8 13.25c0 .687.561 1.248 1.25 1.248.687 0 1.248-.561 1.248-1.249 0-.688-.561-1.249-1.249-1.249zm5.5 0c-.687 0-1.248.561-1.248 1.25 0 .687.561 1.248 1.249 1.248.688 0 1.249-.561 1.249-1.249 0-.687-.562-1.249-1.25-1.249zm-5.466 3.99a.327.327 0 0 0-.231.094.33.33 0 0 0 0 .463c.842.842 2.484.913 2.961.913.477 0 2.105-.056 2.961-.913a.361.361 0 0 0 .029-.463.33.33 0 0 0-.464 0c-.547.533-1.684.73-2.512.73-.828 0-1.979-.196-2.512-.73a.326.326 0 0 0-.232-.095z"/>
                </svg>`;
            case 'pinterest':
                return `<svg class="channel-icon" viewBox="0 0 24 24" fill="${iconColor}">
                    <path d="M12.017 0C5.396 0 .029 5.367.029 11.987c0 5.079 3.158 9.417 7.618 11.174-.105-.949-.199-2.403.041-3.439.219-.937 1.406-5.957 1.406-5.957s-.359-.72-.359-1.781c0-1.663.967-2.911 2.168-2.911 1.024 0 1.518.769 1.518 1.688 0 1.029-.653 2.567-.992 3.992-.285 1.193.6 2.165 1.775 2.165 2.128 0 3.768-2.245 3.768-5.487 0-2.861-2.063-4.869-5.008-4.869-3.41 0-5.409 2.562-5.409 5.199 0 1.033.394 2.143.889 2.741.093.113.105.212.078.326-.085.354-.275 1.122-.312 1.279-.053.225-.172.271-.402.165-1.495-.69-2.433-2.878-2.433-4.646 0-3.776 2.748-7.252 7.92-7.252 4.158 0 7.392 2.967 7.392 6.923 0 4.135-2.607 7.462-6.233 7.462-1.214 0-2.357-.629-2.746-1.378l-.748 2.853c-.271 1.043-1.002 2.35-1.492 3.146C9.57 23.812 10.763 24.009 12.017 24.009c6.624 0 11.99-5.367 11.99-11.988C24.007 5.367 18.641.001.012.001z"/>
                </svg>`;
            default:
                return `<div style="width: 20px; height: 20px; border-radius: 50%; background-color: ${iconColor}; display: inline-block; margin-right: 8px; vertical-align: middle;"></div>`;
        }
    }

    function downloadFile(content, filename, type) {
        const blob = new Blob([content], { type: type });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    function prepareTableData() {
        return currentData.map(row => {
            const contentText = row.content ? 
                (row.content.split(' ').length > 36 ? 
                    row.content.split(' ').slice(0, 36).join(' ') + ' <span style="color: #ccc;">(‚Ä¶)</span>' : 
                    row.content) : '';

            const totalFollowers = 
                (parseFloat(row['source_extended_attributes.facebook_followers']) || 0) +
                (parseFloat(row['source_extended_attributes.twitter_followers']) || 0) +
                (parseFloat(row['source_extended_attributes.instagram_followers']) || 0);

            const totalLikes = 
                (parseFloat(row['article_extended_attributes.facebook_reactions_total']) || 0) +
                (parseFloat(row['article_extended_attributes.instagram_likes']) || 0) +
                (parseFloat(row['article_extended_attributes.twitter_likes']) || 0) +
                (parseFloat(row['article_extended_attributes.youtube_likes']) || 0);

            const totalShares = 
                (parseFloat(row['article_extended_attributes.facebook_shares']) || 0) +
                (parseFloat(row['article_extended_attributes.twitter_retweets']) || 0) +
                (parseFloat(row['article_extended_attributes.twitter_quote_tweets']) || 0) +
                (parseFloat(row['article_extended_attributes.linkedin_shares']) || 0);

            let publishedDate = null;
            if (row.published) {
                if (typeof row.published === 'number') {
                    publishedDate = new Date((row.published - 25569) * 86400 * 1000);
                } else {
                    publishedDate = new Date(row.published);
                }
                
                if (isNaN(publishedDate.getTime()) || publishedDate.getFullYear() < 2020) {
                    publishedDate = null;
                }
            }

            const publishedDateFormatted = publishedDate ? 
                `${publishedDate.toLocaleDateString('it-IT')}<br/>${publishedDate.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' })}` : '-';

            const channelName = getChannelName(row.domain_url || '');

            return {
                profileName: row['extra_author_attributes.name'] || '',
                profileDescription: row['extra_author_attributes.description'] || '',
                channel: channelName,
                publishedDate: publishedDate,
                publishedDateFormatted: publishedDateFormatted,
                content: contentText,
                followers: totalFollowers,
                comments: parseFloat(row['article_extended_attributes.num_comments']) || 0,
                likes: totalLikes,
                shares: totalShares,
                url: row.url || '',
                originalRow: row
            };
        });
    }

    function sortTable(columnIndex) {
        const headers = document.querySelectorAll('#dataTable th');
        
        // Reset all header classes
        headers.forEach(header => {
            header.classList.remove('sort-asc', 'sort-desc');
        });

        // Determine sort direction
        if (sortColumn === columnIndex) {
            sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
        } else {
            sortDirection = 'asc';
            sortColumn = columnIndex;
        }

        // Add appropriate class to current column
        headers[columnIndex].classList.add(sortDirection === 'asc' ? 'sort-asc' : 'sort-desc');

        // Prepare data for sorting
        const tableData = prepareTableData();

        // Sort data based on column
        tableData.sort((a, b) => {
            let valueA, valueB;

            switch (columnIndex) {
                case 0: // Nome Profilo
                    valueA = a.profileName.toLowerCase();
                    valueB = b.profileName.toLowerCase();
                    break;
                case 1: // Canale
                    valueA = a.channel.toLowerCase();
                    valueB = b.channel.toLowerCase();
                    break;
                case 2: // Data e Ora
                    valueA = a.publishedDate || new Date(0);
                    valueB = b.publishedDate || new Date(0);
                    break;
                case 4: // Followers
                    valueA = a.followers;
                    valueB = b.followers;
                    break;
                case 5: // Commenti
                    valueA = a.comments;
                    valueB = b.comments;
                    break;
                case 6: // Like e Reazioni
                    valueA = a.likes;
                    valueB = b.likes;
                    break;
                case 7: // Condivisioni
                    valueA = a.shares;
                    valueB = b.shares;
                    break;
                default:
                    return 0;
            }

            if (typeof valueA === 'string' && typeof valueB === 'string') {
                return sortDirection === 'asc' 
                    ? valueA.localeCompare(valueB)
                    : valueB.localeCompare(valueA);
            } else {
                return sortDirection === 'asc' 
                    ? valueA - valueB
                    : valueB - valueA;
            }
        });

        // Store sorted data
        displayedData = tableData;
        
        // Update table display
        renderTable();
    }

    function renderTable() {
        const maxRowsValue = document.getElementById('maxRows').value;
        const tableBody = document.querySelector('#dataTable tbody');
        const dataToShow = displayedData.length > 0 ? displayedData : prepareTableData();
        
        const limitedData = maxRowsValue === 'all' ? dataToShow : dataToShow.slice(0, parseInt(maxRowsValue));
        let tableHTML = '';

        limitedData.forEach(item => {
            const channelIconHTML = getChannelIconHTML(item.channel);

            const tableRow = `
                <tr>
                    <td class="profile-name-cell">
                        <strong>${item.profileName}</strong>
                        ${item.profileDescription ? `<br/><span style="font-size: 0.85rem; color: #666; font-weight: normal;">${item.profileDescription}</span>` : ''}
                    </td>
                    <td class="channel-cell">${channelIconHTML}${item.channel}</td>
                    <td>
${item.url ? `<a href="${item.url}" target="_blank" rel="noopener">${item.publishedDateFormatted}</a>` : item.publishedDateFormatted}
</td>
                    <td class="content-cell text-left">${item.content}</td>
                    <td>${formatTableValue(item.followers)}</td>
                    <td>${formatTableValue(item.comments)}</td>
                    <td>${formatTableValue(item.likes)}</td>
                    <td>${formatTableValue(item.shares)}</td>
                    
                </tr>
            `;
            tableHTML += tableRow;
        });

        tableBody.innerHTML = tableHTML;
    }

    function generateChannelChart() {
        const channelCounts = {};
        currentData.forEach(row => {
            const channel = getChannelName(row.domain_url || '');
            channelCounts[channel] = (channelCounts[channel] || 0) + 1;
        });

        const sortedChannels = Object.entries(channelCounts)
            .sort(([, a], [, b]) => b - a);

        const channels = sortedChannels.map(([channel]) => channel);
        const values = sortedChannels.map(([, count]) => count);

        const container = document.querySelector('#channelChart');

        /* === Layout parameters === */
        const barWidth = 80;                // larghezza singola barra
        const barSpacing = 10;              // distanza fra le barre
        const marginTop = 60;               // spazio alto (titolo ecc.)
        const marginBottom = 150;            // spazio basso per icone + label
        const chartHeight = 500;            // altezza totale dell‚ÄôSVG
        const chartPaddingX = 50;           // padding orizzontale interno

        const totalBarsWidth = channels.length * barWidth + (channels.length - 1) * barSpacing;
        const chartWidth = Math.max(container.clientWidth || 600, totalBarsWidth + chartPaddingX * 2);

        const barAreaHeight = chartHeight - marginTop - marginBottom;
        const maxValue = Math.max(...values);
        const colors = ['#003d82', '#0056b3', '#ffd100', '#28a745', '#dc3545', '#6f42c1'];

        /* === Build SVG === */
        let svgContent = `
            <svg width="${chartWidth}" height="${chartHeight}" viewBox="0 0 ${chartWidth} ${chartHeight}"
                 xmlns="http://www.w3.org/2000/svg" style="margin:0 auto;display:block;"
                 preserveAspectRatio="xMidYMid meet">
                <style>
                    .chart-bar { transition: opacity 0.2s, transform 0.15s; }
                    .chart-bar:hover { opacity: 0.8; transform: translateY(-4px); }
                    .chart-value { font-family: 'Inter', sans-serif; font-size: 14px; font-weight: 700; fill: var(--primary-blue); text-anchor: middle; }
                    .chart-label { font-family: 'Inter', sans-serif; font-size: 14px; fill: var(--primary-blue); text-anchor: middle; }
                </style>`;

        /* Center bars horizontally */
        const startX = (chartWidth - totalBarsWidth) / 2;

        channels.forEach((channel, index) => {
            const barHeight = Math.max((values[index] / maxValue) * barAreaHeight, 30);
            const x = startX + index * (barWidth + barSpacing);
            const y = marginTop + (barAreaHeight - barHeight);

            // primary bar
            svgContent += `
                <rect class="chart-bar" x="${x}" y="${y}" width="${barWidth}" height="${barHeight}"
                      fill="${colors[index % colors.length]}" rx="4" ry="4"/>
                <text x="${x + barWidth/2}" y="${y - 10}" class="chart-value">${formatNumber(values[index])}</text>`;

            // icon + label
            const iconY = chartHeight - marginBottom + 30; // posiziona l‚Äôicona
            svgContent += `
                ${getChannelIconSVG(channel, x + barWidth/2 - 8, iconY - 18, 18)}
                <text x="${x + barWidth/2}" y="${iconY + 22}" class="chart-label">${channel}</text>`;
        });

        svgContent += '</svg>';
        container.innerHTML = svgContent;
    }

    function generateSentimentChart() {
        const sentiments = { positive: 0, neutral: 0, negative: 0 };
        
        currentData.forEach(row => {
            const sentiment = parseFloat(row.sentiment) || 0;
            if (sentiment > 0) sentiments.positive++;
            else if (sentiment < 0) sentiments.negative++;
            else sentiments.neutral++;
        });

        const total = sentiments.positive + sentiments.neutral + sentiments.negative;
        const positivePerc = total > 0 ? Math.round((sentiments.positive / total) * 100) : 0;
        const neutralPerc = total > 0 ? Math.round((sentiments.neutral / total) * 100) : 0;
        const negativePerc = total > 0 ? Math.round((sentiments.negative / total) * 100) : 0;

        const container = document.getElementById('sentimentContainer');
        const svgSize = 380;
        const chartRadius = 90;
        const innerRadius = 50;
        const centerX = svgSize / 2;
        const centerY = svgSize / 2 - 20;

        function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
            const angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
            return {
                x: centerX + (radius * Math.cos(angleInRadians)),
                y: centerY + (radius * Math.sin(angleInRadians))
            };
        }

        const colors = ['#28a745', '#ffc107', '#dc3545'];
        const labels = ['Positivo', 'Neutro', 'Negativo'];
        const values = [positivePerc, neutralPerc, negativePerc];

        let svgContent = `
            <svg viewBox="0 0 ${svgSize} ${svgSize}" xmlns="http://www.w3.org/2000/svg" style="margin: 0 auto; display: block;" preserveAspectRatio="xMidYMid meet">
                <defs>
                    <style>
                        .sentiment-value { 
                            font-family: 'Avenir Next LT Pro', Arial, sans-serif; 
                            font-size: 14px; 
                            fill: white; 
                            font-weight: bold; 
                            text-anchor: middle; 
                        }
                        .legend-item { 
                            font-family: 'Avenir Next LT Pro', Arial, sans-serif; 
                            font-size: 12px; 
                            fill: #333; 
                            font-weight: 500;
                        }
                        .legend-perc { 
                            font-family: 'Avenir Next LT Pro', Arial, sans-serif; 
                            font-size: 11px; 
                            fill: #666; 
                        }
                        .donut-segment {
                            transition: all 0.3s ease;
                        }
                        .donut-segment:hover {
                            filter: brightness(1.1);
                        }
                    </style>
                </defs>`;

        let currentAngle = 0;
        values.forEach((value, index) => {
            if (value > 0) {
                const segmentAngle = (value / 100) * 360;
                const startAngle = currentAngle;
                const endAngle = currentAngle + segmentAngle;
                
                const outerStart = polarToCartesian(centerX, centerY, chartRadius, startAngle);
                const outerEnd = polarToCartesian(centerX, centerY, chartRadius, endAngle);
                const innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngle);
                const innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngle);
                
                const largeArc = segmentAngle > 180 ? 1 : 0;
                
                const pathData = [
                    `M ${outerStart.x} ${outerStart.y}`,
                    `A ${chartRadius} ${chartRadius} 0 ${largeArc} 1 ${outerEnd.x} ${outerEnd.y}`,
                    `L ${innerEnd.x} ${innerEnd.y}`,
                    `A ${innerRadius} ${innerRadius} 0 ${largeArc} 0 ${innerStart.x} ${innerStart.y}`,
                    'Z'
                ].join(' ');
                
                svgContent += `<path class="donut-segment" d="${pathData}" fill="${colors[index]}" stroke="white" stroke-width="2"/>`;

                // Aggiungi percentuale se il segmento √® abbastanza grande
                if (value > 10) {
                    const midAngle = startAngle + segmentAngle / 2;
                    const textRadius = (chartRadius + innerRadius) / 2;
                    const textPos = polarToCartesian(centerX, centerY, textRadius, midAngle);
                    svgContent += `
                        <text x="${textPos.x}" y="${textPos.y + 4}" class="sentiment-value">
                            ${value}%
                        </text>`;
                }
                
                currentAngle += segmentAngle;
            }
        });

        // Legenda orizzontale sotto il grafico
        const legendY = svgSize - 60;
        const legendSpacing = 110;
        const legendStartX = (svgSize - (labels.length * legendSpacing)) / 2;
        
        labels.forEach((label, index) => {
            const legendX = legendStartX + (index * legendSpacing);
            svgContent += `
                <circle cx="${legendX + 8}" cy="${legendY}" r="6" fill="${colors[index]}"/>
                <text x="${legendX + 20}" y="${legendY - 5}" class="legend-item">
                    ${label}
                </text>
                <text x="${legendX + 20}" y="${legendY + 8}" class="legend-perc">
                    ${values[index]}%
                </text>`;
        });

        svgContent += '</svg>';
        container.innerHTML = svgContent;
    }

    function generateReport() {
        const argomento = document.getElementById('argomento').value || 'Analisi Social';
        const dataInizio = document.getElementById('dataInizio').value;
        const dataFine = document.getElementById('dataFine').value;

        if (currentData.length === 0) {
            showError('Carica prima un file Excel per generare il report.');
            return;
        }

        document.getElementById('analysisTitle').textContent = `Analisi social su ${argomento}`;
        
        let dateRange = 'Periodo non specificato';
        if (dataInizio && dataFine) {
            const startDate = new Date(dataInizio).toLocaleDateString('it-IT');
            const endDate = new Date(dataFine).toLocaleDateString('it-IT');
            dateRange = `${startDate} - ${endDate}`;
        }
        document.getElementById('analysisSubtitle').textContent = `Report riferito al periodo: ${dateRange}`;

        generateMetrics();
        generateChannelChart();
        generateSentimentChart();
        
        // Reset sorting and display original data
        sortColumn = -1;
        sortDirection = 'asc';
        displayedData = [];
        const headers = document.querySelectorAll('#dataTable th');
        headers.forEach(header => {
            header.classList.remove('sort-asc', 'sort-desc');
        });
        
        updateTable();

        document.getElementById('results').style.display = 'block';
        document.getElementById('results').scrollIntoView({ behavior: 'smooth' });
    }

    function generateMetrics() {
        const totalPosts = currentData.length;
        const totalComments = currentData.reduce((sum, row) => {
            return sum + (parseFloat(row['article_extended_attributes.num_comments']) || 0);
        }, 0);
        const totalLikes = currentData.reduce((sum, row) => {
            return sum + 
                (parseFloat(row['article_extended_attributes.facebook_reactions_total']) || 0) +
                (parseFloat(row['article_extended_attributes.instagram_likes']) || 0) +
                (parseFloat(row['article_extended_attributes.twitter_likes']) || 0) +
                (parseFloat(row['article_extended_attributes.youtube_likes']) || 0);
        }, 0);
        const totalShares = currentData.reduce((sum, row) => {
            return sum + 
                (parseFloat(row['article_extended_attributes.facebook_shares']) || 0) +
                (parseFloat(row['article_extended_attributes.twitter_retweets']) || 0) +
                (parseFloat(row['article_extended_attributes.twitter_quote_tweets']) || 0) +
                (parseFloat(row['article_extended_attributes.linkedin_shares']) || 0);
        }, 0);

        const metricsGrid = document.getElementById('metricsGrid');
        metricsGrid.innerHTML = `
            <div class="metric-card">
                <div class="metric-value">${formatNumber(totalPosts)}</div>
                <div class="metric-label">Post Totali</div>
            </div>
            <div class="metric-card">
                <div class="metric-value">${formatNumber(totalComments)}</div>
                <div class="metric-label">Commenti Totali</div>
            </div>
            <div class="metric-card">
                <div class="metric-value">${formatNumber(totalLikes)}</div>
                <div class="metric-label">Like e Reazioni</div>
            </div>
            <div class="metric-card">
                <div class="metric-value">${formatNumber(totalShares)}</div>
                <div class="metric-label">Condivisioni</div>
            </div>
        `;
    }

    function updateTable() {
        renderTable();
    }

    function exportMetricsSVG() {
        const button = event.target.closest('button');
        const originalText = button.innerHTML;
        button.innerHTML = '‚è≥ Generazione...';
        button.disabled = true;
        
        setTimeout(() => {
            try {
                const totalPosts = currentData.length;
                const totalComments = currentData.reduce((sum, row) => {
                    return sum + (parseFloat(row['article_extended_attributes.num_comments']) || 0);
                }, 0);
                const totalLikes = currentData.reduce((sum, row) => {
                    return sum + 
                        (parseFloat(row['article_extended_attributes.facebook_reactions_total']) || 0) +
                        (parseFloat(row['article_extended_attributes.instagram_likes']) || 0) +
                        (parseFloat(row['article_extended_attributes.twitter_likes']) || 0) +
                        (parseFloat(row['article_extended_attributes.youtube_likes']) || 0);
                }, 0);
                const totalShares = currentData.reduce((sum, row) => {
                    return sum + 
                        (parseFloat(row['article_extended_attributes.facebook_shares']) || 0) +
                        (parseFloat(row['article_extended_attributes.twitter_retweets']) || 0) +
                        (parseFloat(row['article_extended_attributes.twitter_quote_tweets']) || 0) +
                        (parseFloat(row['article_extended_attributes.linkedin_shares']) || 0);
                }, 0);

                const metricsSVG = `
                    <svg width="1000" height="300" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <style>
                                .metric-rect { fill: url(#blueGradient); }
                                .metric-title { font-family: 'Avenir Next LT Pro', Arial, sans-serif; font-size: 24px; fill: #003d82; font-weight: normal; text-anchor: middle; text-transform: uppercase; }
                                .metric-value { font-family: 'Avenir Next LT Pro', Arial, sans-serif; font-size: 36px; fill: white; font-weight: bold; text-anchor: middle; }
                                .metric-label { font-family: 'Avenir Next LT Pro', Arial, sans-serif; font-size: 16px; fill: white; font-weight: normal; text-anchor: middle; }
                            </style>
                            <linearGradient id="blueGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#003d82;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#0056b3;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <text x="500" y="30" class="metric-title">METRICHE GENERALI</text>
                        
                        <rect x="50" y="60" width="200" height="180" rx="16" class="metric-rect"/>
                        <text x="150" y="130" class="metric-value">${formatNumber(totalPosts)}</text>
                        <text x="150" y="200" class="metric-label">Post Totali</text>
                        
                        <rect x="280" y="60" width="200" height="180" rx="16" class="metric-rect"/>
                        <text x="380" y="130" class="metric-value">${formatNumber(totalComments)}</text>
                        <text x="380" y="200" class="metric-label">Commenti Totali</text>
                        
                        <rect x="510" y="60" width="200" height="180" rx="16" class="metric-rect"/>
                        <text x="610" y="130" class="metric-value">${formatNumber(totalLikes)}</text>
                        <text x="610" y="200" class="metric-label">Like e Reazioni</text>
                        
                        <rect x="740" y="60" width="200" height="180" rx="16" class="metric-rect"/>
                        <text x="840" y="130" class="metric-value">${formatNumber(totalShares)}</text>
                        <text x="840" y="200" class="metric-label">Condivisioni</text>
                    </svg>`;

                const argomento = document.getElementById('argomento').value || 'report';
                downloadFile(metricsSVG, `metriche-talkwalker-${argomento.replace(/\s+/g, '-').toLowerCase()}.svg`, 'image/svg+xml');
                button.innerHTML = '‚úÖ Completato';
            } catch (error) {
                console.error('Errore esportazione SVG:', error);
                button.innerHTML = '‚ùå Errore';
            } finally {
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.disabled = false;
                }, 2000);
            }
        }, 500);
    }

    function exportChannelChartSVG() {
        const button = event.target.closest('button');
        const originalText = button.innerHTML;
        button.innerHTML = '‚è≥ Generazione...';
        button.disabled = true;
        
        setTimeout(() => {
            try {
                const channelCounts = {};
                currentData.forEach(row => {
                    const channel = getChannelName(row.domain_url || '');
                    channelCounts[channel] = (channelCounts[channel] || 0) + 1;
                });

                const sortedChannels = Object.entries(channelCounts)
                    .sort(([, a], [, b]) => b - a);

                const channels = sortedChannels.map(([channel]) => channel);
                const values = sortedChannels.map(([, count]) => count);

                const chartWidth = 800;
                const chartHeight = 600;
                const barWidth = 80;
                const barSpacing = 10;
                const marginTop = 100;
                const marginBottom = 150;
                const barAreaHeight = chartHeight - marginTop - marginBottom;
                const maxValue = Math.max(...values);
                const colors = ['#003d82', '#0056b3', '#ffd100', '#28a745', '#dc3545', '#6f42c1'];
                const totalBarsWidth = channels.length * barWidth + (channels.length - 1) * barSpacing;
                const startX = (chartWidth - totalBarsWidth) / 2;

                let svgContent = `
                    <svg width="${chartWidth}" height="${chartHeight}" viewBox="0 0 ${chartWidth} ${chartHeight}"
                         xmlns="http://www.w3.org/2000/svg" style="margin:0 auto;display:block;"
                         preserveAspectRatio="xMidYMid meet">
                        <style>
                            .chart-title {
                                font-family: 'Avenir Next LT Pro', Arial, sans-serif;
                                font-size: 24px;
                                font-weight: 300;
                                fill: #1d48b4;
                                text-anchor: middle;
                                text-transform: uppercase;
                            }
                            .chart-bar { transition: opacity 0.2s, transform 0.15s; }
                            .chart-value { font-family: 'Inter', sans-serif; font-size: 14px; font-weight: 700; fill: var(--primary-blue); text-anchor: middle; }
                            .chart-label { font-family: 'Inter', sans-serif; font-size: 14px; fill: var(--primary-blue); text-anchor: middle; }
                        </style>
                        <text x="${chartWidth/2}" y="40" class="chart-title">POST PER CANALE</text>`;

                channels.forEach((channel, index) => {
                    const barHeight = Math.max((values[index] / maxValue) * barAreaHeight, 30);
                    const x = startX + index * (barWidth + barSpacing);
                    const y = marginTop + (barAreaHeight - barHeight);

                    svgContent += `
                        <rect class="chart-bar" x="${x}" y="${y}" width="${barWidth}" height="${barHeight}"
                              fill="${colors[index % colors.length]}" rx="4" ry="4"/>
                        <text x="${x + barWidth/2}" y="${y - 10}" class="chart-value">${formatNumber(values[index])}</text>`;

                    const iconY = chartHeight - marginBottom + 30;
                    svgContent += `
                        ${getChannelIconSVG(channel, x + barWidth/2 - 8, iconY - 18, 18)}
                        <text x="${x + barWidth/2}" y="${iconY + 22}" class="chart-label">${channel}</text>`;
                });

                svgContent += '</svg>';

                const argomento = document.getElementById('argomento').value || 'report';
                downloadFile(svgContent, `grafico-canali-talkwalker-${argomento.replace(/\s+/g, '-').toLowerCase()}.svg`, 'image/svg+xml');
                button.innerHTML = '‚úÖ Completato';
            } catch (error) {
                console.error('Errore esportazione SVG:', error);
                button.innerHTML = '‚ùå Errore';
            } finally {
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.disabled = false;
                }, 2000);
            }
        }, 500);
    }

    function exportSentimentChartSVG() {
        const button = event.target.closest('button');
        const originalText = button.innerHTML;
        button.innerHTML = '‚è≥ Generazione...';
        button.disabled = true;
        
        setTimeout(() => {
            try {
                const sentiments = { positive: 0, neutral: 0, negative: 0 };
                
                currentData.forEach(row => {
                    const sentiment = parseFloat(row.sentiment) || 0;
                    if (sentiment > 0) sentiments.positive++;
                    else if (sentiment < 0) sentiments.negative++;
                    else sentiments.neutral++;
                });

                const total = sentiments.positive + sentiments.neutral + sentiments.negative;
                const positivePerc = total > 0 ? Math.round((sentiments.positive / total) * 100) : 0;
                const neutralPerc = total > 0 ? Math.round((sentiments.neutral / total) * 100) : 0;
                const negativePerc = total > 0 ? Math.round((sentiments.negative / total) * 100) : 0;

                const svgSize = 600;
                const chartRadius = 120;
                const innerRadius = 70;
                const centerX = svgSize / 2;
                const centerY = svgSize / 2;

                function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
                    const angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
                    return {
                        x: centerX + (radius * Math.cos(angleInRadians)),
                        y: centerY + (radius * Math.sin(angleInRadians))
                    };
                }

                const colors = ['#28a745', '#ffc107', '#dc3545'];
                const labels = ['Positivo', 'Neutro', 'Negativo'];
                const values = [positivePerc, neutralPerc, negativePerc];

                let svgContent = `
                    <svg viewBox="0 0 ${svgSize} ${svgSize}" xmlns="http://www.w3.org/2000/svg" style="margin: 0 auto; display: block;" preserveAspectRatio="xMidYMid meet">
                        <defs>
                            <style>
                                .chart-title {
                                    font-family: 'Avenir Next LT Pro', Arial, sans-serif;
                                    font-size: 24px;
                                    font-weight: 300;
                                    fill: #1d48b4;
                                    text-anchor: middle;
                                    text-transform: uppercase;
                                }
                                .sentiment-value { 
                                    font-family: 'Avenir Next LT Pro', Arial, sans-serif; 
                                    font-size: 16px; 
                                    fill: white; 
                                    font-weight: bold; 
                                    text-anchor: middle; 
                                }
                                .legend-item { 
                                    font-family: 'Avenir Next LT Pro', Arial, sans-serif; 
                                    font-size: 14px; 
                                    fill: #333; 
                                    font-weight: 500;
                                }
                                .legend-perc { 
                                    font-family: 'Avenir Next LT Pro', Arial, sans-serif; 
                                    font-size: 12px; 
                                    fill: #666; 
                                }
                                .donut-segment {
                                    transition: all 0.3s ease;
                                }
                            </style>
                        </defs>
                        <text x="${svgSize/2}" y="50" class="chart-title">ANALISI DEL SENTIMENT</text>`;

                let currentAngle = 0;
                values.forEach((value, index) => {
                    if (value > 0) {
                        const segmentAngle = (value / 100) * 360;
                        const startAngle = currentAngle;
                        const endAngle = currentAngle + segmentAngle;
                        
                        const outerStart = polarToCartesian(centerX, centerY, chartRadius, startAngle);
                        const outerEnd = polarToCartesian(centerX, centerY, chartRadius, endAngle);
                        const innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngle);
                        const innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngle);
                        
                        const largeArc = segmentAngle > 180 ? 1 : 0;
                        
                        const pathData = [
                            `M ${outerStart.x} ${outerStart.y}`,
                            `A ${chartRadius} ${chartRadius} 0 ${largeArc} 1 ${outerEnd.x} ${outerEnd.y}`,
                            `L ${innerEnd.x} ${innerEnd.y}`,
                            `A ${innerRadius} ${innerRadius} 0 ${largeArc} 0 ${innerStart.x} ${innerStart.y}`,
                            'Z'
                        ].join(' ');
                        
                        svgContent += `<path class="donut-segment" d="${pathData}" fill="${colors[index]}" stroke="white" stroke-width="2"/>`;

                        if (value > 10) {
                            const midAngle = startAngle + segmentAngle / 2;
                            const textRadius = (chartRadius + innerRadius) / 2;
                            const textPos = polarToCartesian(centerX, centerY, textRadius, midAngle);
                            svgContent += `
                                <text x="${textPos.x}" y="${textPos.y + 5}" class="sentiment-value">
                                    ${value}%
                                </text>`;
                        }
                        
                        currentAngle += segmentAngle;
                    }
                });

                const legendY = svgSize - 100;
                const legendSpacing = 150;
                const legendStartX = (svgSize - (labels.length * legendSpacing)) / 2;
                
                labels.forEach((label, index) => {
                    const legendX = legendStartX + (index * legendSpacing);
                    svgContent += `
                        <circle cx="${legendX + 8}" cy="${legendY}" r="8" fill="${colors[index]}"/>
                        <text x="${legendX + 25}" y="${legendY - 5}" class="legend-item">
                            ${label}
                        </text>
                        <text x="${legendX + 25}" y="${legendY + 10}" class="legend-perc">
                            ${values[index]}%
                        </text>`;
                });

                svgContent += '</svg>';

                const argomento = document.getElementById('argomento').value || 'report';
                downloadFile(svgContent, `grafico-sentiment-talkwalker-${argomento.replace(/\s+/g, '-').toLowerCase()}.svg`, 'image/svg+xml');
                button.innerHTML = '‚úÖ Completato';
            } catch (error) {
                console.error('Errore esportazione SVG:', error);
                button.innerHTML = '‚ùå Errore';
            } finally {
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.disabled = false;
                }, 2000);
            }
        }, 500);
    }

    function exportExcel() {
        const button = event.target.closest('button');
        const originalText = button.innerHTML;
        button.innerHTML = '‚è≥ Generazione...';
        button.disabled = true;
        
        setTimeout(() => {
            try {
                const wb = XLSX.utils.book_new();
                
                // Use current table data (sorted if applicable)
                const tableData = displayedData.length > 0 ? displayedData : prepareTableData();
                const fullTableData = [];
                const headers = ['Nome Profilo', 'Canale', 'Data e Ora', 'Contenuto', 'Followers', 'Commenti', 'Like e Reazioni', 'Condivisioni', 'Link'];
                fullTableData.push(headers);

                tableData.forEach(item => {
                    const contentTextForExcel = item.originalRow.content ? 
                        (item.originalRow.content.split(' ').length > 36 ? 
                            item.originalRow.content.split(' ').slice(0, 36).join(' ') + '...' : 
                            item.originalRow.content) : '';

                    let publishedDateForExcel = '';
                    if (item.publishedDate) {
                        publishedDateForExcel = item.publishedDate.toLocaleString('it-IT');
                    }

                    const profileNameWithDescription = item.profileDescription ? 
                        `${item.profileName} - ${item.profileDescription}` : item.profileName;

                    fullTableData.push([
                        profileNameWithDescription,
                        item.channel,
                        publishedDateForExcel,
                        contentTextForExcel,
                        item.followers === 0 ? '' : item.followers,
                        item.comments === 0 ? '' : item.comments,
                        item.likes === 0 ? '' : item.likes,
                        item.shares === 0 ? '' : item.shares,
                        item.url
                    ]);
                });

                const ws = XLSX.utils.aoa_to_sheet(fullTableData);
                XLSX.utils.book_append_sheet(wb, ws, "Report Talkwalker");
                
                const argomento = document.getElementById('argomento').value || 'report';
                XLSX.writeFile(wb, `report-talkwalker-${argomento.replace(/\s+/g, '-').toLowerCase()}.xlsx`);
                button.innerHTML = '‚úÖ Completato';
            } catch (error) {
                console.error('Errore esportazione Excel:', error);
                button.innerHTML = '‚ùå Errore';
            } finally {
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.disabled = false;
                }, 2000);
            }
        }, 500);
    }

    function exportHTML() {
        const button = event.target.closest('button');
        const originalText = button.innerHTML;
        button.innerHTML = '‚è≥ Generazione...';
        button.disabled = true;
        
        setTimeout(() => {
            try {
                const maxRowsValue = document.getElementById('maxRows').value;
                const tableData = displayedData.length > 0 ? displayedData : prepareTableData();
                const limitedData = maxRowsValue === 'all' ? tableData : tableData.slice(0, parseInt(maxRowsValue));

                let tableHTML = `
                    <table class="data-table" id="dataTable">
                        <thead>
                            <tr>
                                <th>Nome Profilo</th>
                                <th>Canale</th>
                                <th>Data e Ora</th>
                                <th>Contenuto</th>
                                <th>Followers</th>
                                <th>Commenti</th>
                                <th>Like e Reazioni</th>
                                <th>Condivisioni</th>
                            </tr>
                        </thead>
                        <tbody>`;

                limitedData.forEach(item => {
                    const channelIconHTML = getChannelIconHTML(item.channel);
                    tableHTML += `
                        <tr>
                            <td class="profile-name-cell">
                                <strong>${item.profileName}</strong>
                                ${item.profileDescription ? `<br/><span style="font-size: 0.85rem; color: #666; font-weight: normal;">${item.profileDescription}</span>` : ''}
                            </td>
                            <td class="channel-cell">${channelIconHTML}${item.channel}</td>
                            <td>
${item.url ? `<a href="${item.url}" target="_blank" rel="noopener">${item.publishedDateFormatted}</a>` : item.publishedDateFormatted}
</td>
                            <td class="content-cell text-left">${item.content}</td>
                            <td>${formatTableValue(item.followers)}</td>
                            <td>${formatTableValue(item.comments)}</td>
                            <td>${formatTableValue(item.likes)}</td>
                            <td>${formatTableValue(item.shares)}</td>
                        </tr>`;
                });

                tableHTML += `
                        </tbody>
                    </table>`;

                const argomento = document.getElementById('argomento').value || 'report';
                const resultsElement = document.getElementById('results');
                
                const resultsClone = resultsElement.cloneNode(true);
                
                const tableControlsAll = resultsClone.querySelectorAll('.table-controls, .rows-selector, button[onclick="updateTable()"]');
                tableControlsAll.forEach(el => el.remove());

                const exportSection = resultsClone.querySelector('.card:last-child');
                if (exportSection) exportSection.remove();
                
                const tableControls = resultsClone.querySelector('.table-controls');
                if (tableControls) tableControls.remove();

                const tableWrapper = resultsClone.querySelector('.table-wrapper');
                if (tableWrapper) {
                    tableWrapper.innerHTML = tableHTML;
                }

                const channelChartElement = document.querySelector('#channelChart svg');
                const sentimentChartElement = document.querySelector('#sentimentContainer svg');
                
                const channelChartClone = resultsClone.querySelector('#channelChart');
                if (channelChartClone && channelChartElement) {
                    channelChartClone.innerHTML = channelChartElement.outerHTML;
                }
                
                const sentimentChartClone  = resultsClone.querySelector('#sentimentContainer');
if (sentimentChartClone) {
    if (!document.querySelector('#sentimentContainer svg')) {
        generateSentimentChart();
    }
    sentimentChartClone.innerHTML = document.getElementById('sentimentContainer').innerHTML;
}
const htmlContent = `<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Report Talkwalker - ${argomento}</title>
    <style>
        ${document.querySelector('style').innerHTML}
        .header { display: none; }
        .upload-section { display: none; }
        
        .data-table th:hover { background: linear-gradient(135deg, var(--light-blue), #f0f8ff); }
    
.chart-container,
.sentiment-container{
    width:100%;
    margin:0 auto;
}
    margin:0 auto;
}
.chart-container svg,
.sentiment-container svg{
    width:100% !important;
    height:auto !important;
}
</style>
</head>
<body>
    <div class="container">
        ${resultsClone.innerHTML}
    </div>
</body>
</html>`;

                downloadFile(htmlContent, `report-talkwalker-${argomento.replace(/\s+/g, '-').toLowerCase()}.html`, 'text/html');
                button.innerHTML = '‚úÖ Completato';
            } catch (error) {
                console.error('Errore esportazione HTML:', error);
                button.innerHTML = '‚ùå Errore';
            } finally {
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.disabled = false;
                }, 2000);
            }
        }, 500);
    }

    // Inizializzazione DOM
    document.addEventListener('DOMContentLoaded', function() {
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('dataFine').value = today;
        
        const weekAgo = new Date();
        weekAgo.setDate(weekAgo.getDate() - 7);
        document.getElementById('dataInizio').value = weekAgo.toISOString().split('T')[0];
    });

    // Event listeners per drag & drop
    const uploadArea = document.querySelector('.upload-area');
    
    uploadArea.addEventListener('dragover', function(e) {
        e.preventDefault();
        uploadArea.style.backgroundColor = '#d0e8ff';
    });

    uploadArea.addEventListener('dragleave', function(e) {
        e.preventDefault();
        uploadArea.style.backgroundColor = '';
    });

    uploadArea.addEventListener('drop', function(e) {
        e.preventDefault();
        uploadArea.style.backgroundColor = '';
        
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            const file = files[0];
            if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                document.getElementById('fileInput').files = files;
                handleFile({ target: { files: files } });
            } else {
                showError('Per favore carica un file Excel (.xlsx o .xls)');
            }
        }
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.key === 'g') {
            e.preventDefault();
            if (!document.getElementById('generateBtn').disabled) {
                generateReport();
            }
        }
        
        if (e.ctrlKey && e.key === 'e') {
            e.preventDefault();
            if (document.getElementById('results').style.display === 'block') {
                exportExcel();
            }
        }
    });

    window.addEventListener('error', function(e) {
        console.error('Errore nell\'applicazione:', e.error);
        showError('Si √® verificato un errore. Ricarica la pagina e riprova.');
    });

    if (typeof performance !== 'undefined') {
        window.addEventListener('load', function() {
            setTimeout(() => {
                const perfData = performance.getEntriesByType('navigation')[0];
                console.log(`‚ö° Tempo di caricamento: ${Math.round(perfData.loadEventEnd - perfData.fetchStart)}ms`);
            }, 0);
        });
    }

    window.addEventListener('load', function() {
        console.log('‚úÖ Applicazione Talkwalker completamente caricata e funzionale');
        
        document.body.addEventListener('click', function(e) {
            if (e.target.matches('.metric-card')) {
                e.target.style.transform = 'scale(1.05)';
                setTimeout(() => {
                    e.target.style.transform = '';
                }, 200);
            }
        });
    });

    console.log('üöÄ Talkwalker Report Generator caricato con successo!');
</script>
</body>
</html>
